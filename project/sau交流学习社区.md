# [sau交流学习社区](https://www.mwcxs.top/)
sau交流学习社区，一个技术分享和技术谈论的社区，技术栈：thinkjs2+jq+nunjucks+mysql+redis+nginx，个人全栈开发。
拥有文章管理，微型bbs社区，防止csrf攻击，权限管理，定时任务，页面后台配置，github第三方登陆，从中学会了使用
thinkjs后端开发，redis缓存频繁查库的信息，nginx处理静态文件，设计网站安全，优化网站渲染速度。

思考：
### 1、thinkjs2和thinkjs3的区别？
（1）thinkjs1.0在14年发布，360团队的李成银设计和开发，借鉴了thinkphp框架。
thinkjs2.0在15年发布，具备了可扩展性，支持ES6/ES7，支持TypeScript，性能提升。
框架是否出色，一看支持功能，二看性能，thinkjs更适合大型项目，功能和复杂度远超过express和koa，
但是性能不比他们逊色多少。
（2）thinkjs2主要特点：
+ 支持TypeScript
+ 升级babel到6
+ 多级控制器（controller可以建立子目录，目录的深度根据项目复杂度来定）
+ 支持postgreSQL，（目前支持4种数据库，mysql，SQLite，MongoDB，postgreSQL）
（3）thinkjs3.0在17年发布
最大改变时底层架构基于koa2.0重构，koa2.0稳定，koa2.0的洋葱模型的中间件更能满足多维度的需求，thinkjs3兼容koa的中间件，可以说是站在koa这个巨人的肩膀上做的更好。
koa2.0使用更优雅的async/await解决异步问题。node8.0后async/await被原生支持，不用借助babel转译。
+ 2内置很多功能，3不再提供丰富的功能，而是提供最基本核心，通过扩展和适配器可以满足不同需求。
+ 多进程模型，新增think-cluster模块内置多进程模型，最大限度的利用多核CPU提高响应速度，同时提供一套进程之间通信方式，
比如：通知其他进程执行某一个任务，代码更新后会重启所有的子进程。
+ 智能的错误提示。差错和定位问题，尤其是使用babel转译后，所以新增think-trace模块追踪错误问题，显示错误堆栈信息。
+ 强化定时任务功能，新增think-crontab模块。
+ 重构日志功能，基于think-logger3构建日志系统
+ 重构框架操作数据库操作逻辑

### 2、nunjucks模板引擎
nunjucks是Mozilla开发的一个纯js编写的模板引擎，可以运行在node端，又可以运行在浏览器端。nunjucks借鉴用python写的jinja2模板引擎。
我们知道flask框架下的jinja2模板引擎，jinjia2是由python实现的模板语言，设计思想来源于Django模板引擎，是flask框架内置模板语言。

使用模板好处：
+ 视图函数只负责业务逻辑处理和数据处理（业务逻辑方面）
+ 模板取到视图函数的数据结果进行展示（视图展示方面）
+ 代码结构清晰，耦合度低

### 3、项目如何具体防止csrf攻击
csrf是跨站请求伪造，本质是网站对浏览器的信任。简单说，就是利用用户的登陆状态发起恶意请求。

我在系统中做的是所有的接口请求都加csrf，thinkjs有针对csrf的配置，我们举个简单例子：

在页面初始化的时候，后端从session中获取csrf值，然后传到前台页面，前台页面整个影藏域存放csrf值。在base.js中统一assign，这样所有页面都有这个值。
然后发送接口的时候，传输数据添加csrf参数；然后验证这个csrf参数，并且请求时附带验证码或者token。

### 4、还有其他的csrf攻击防御措施吗？
+ 尽量使用post请求，限制使用get请求，get请求不修改数据。post不是万无一失的，攻击者需要伪装一个form，增加了csrf暴露的可能性。
+ 将cookie设置为httpOnly。这样通过程序就无法读取到cookie信息，避免了攻击者伪造cookie情况。
+ 将cookie设置为sameSite属性，不随着跨域请求发送。
+ 请求参数中附带验证信息，比如随机token或者验证码，后端进行校验
+ 通过HTTP头部字段Referer识别，阻止第三方网站访问请求接口。这个字段referer记录http请求的来源地址。

### 5、常见的其他攻击，比如xss？安全策略CSP？密码安全，密码加盐？
xss叫跨网站指令码，通过修改html节点或者执行js攻击网站。
如何防御？
+ 转译所有输入和输出的内容，对于括号，尖括号，斜杠进行转译
+ 富文本，可以采用白名单过滤
+ CSP内容安全策略，建立白名单，规定浏览器只能执行特定来源的代码，通过http的header中的content-security-policy来开启csp。


### 6、如何实现github第三方登陆？
第三方登陆实质是OAuth授权。
说一个具体场景：想登陆A网站，A网站让用户提供第三方的数据证明自己的身份。获取第三方网站的身份数据，这就需要Oauth授权。

流程：
+ A网站让用户跳转到Github
+ Github要求用户登陆，然后询问“A网站要求获得XX权限，你是否同意？”
+ 用户同意，Github会重定向回A网站，同时发送一个授权码
+ A网站使用授权码，向Github请求令牌
+ Github返回令牌
+ A网站使用令牌，向Github请求用户数据

### 7、redis缓存
redis是一个开源的，C语言编写，支持网络，可基于内存并且持久化的日志型，key-value数据库，非关系型数据库。**内存中的数据结构存储系统**，可用作数据库，缓存和消息中间件。

支持多种数据类型：
+ 字符串（String）
+ 字典（hash）
+ 列表（list）
+ 集合（set）
+ 有序集合（sorted set）

基本配合后端数据库使用，存放只是用户当前频繁调用的数据。

功能特点：
+ 高速读写（因为内存上的数据库）
+ 数据类型丰富
+ 支持持久化AOF和RDB
+ 多种内存分配及回收策略
+ 支持多事物
+ 消息队列，消息订阅
+ 支持高可用
+ 支持分布式分片集群

优点：高性能读写，多数据类型支持，数据持久化，高可用架构，支持自定义虚拟内存，支持分布式分片集群，单线程读写性能高。

缺点：多线程读写较mencached慢。

什么是redis持久化？有几种持久化方式，优缺点？
+ 持久化：把redis内存中的数据写到磁盘中，防止服务器宕机了内存数据丢失。
+ 方式：RDB（默认）和AOF
+ 优缺点：RDB是数据快照，指定间隔对数据快照。AOF是执行写操作的时候会触发，写入保护。
+ 存储结构：内饰RESP协议的文本存储
+ 比较：1、AOF比RDB更新频率高，优先使用AOF还原数据。2、AOF比RDB安全，更大。3、RDB性能比AOF好。4、两个都配置时，优先加载AOF。

什么是RESP通讯协议？
+ redis客户端和服务端之间使用的通讯协议
+ 特点：实现简单，快速解析，可读性好

redis的架构模式及特点？
+ 单机版
    > + 优点：简单，
    > + 缺点：但是内存容量有限，处理能力有限，无法高可用。
+ 主从复制：主从服务器之间更新同步
    > + 优点：主从服务器会具有相同的数据，降低住服务器压力转交给从库。
    > + 缺点：无法高可用，没有解决master写的压力
+ 哨兵：使用sentinel监控主从服务器
    > + 优点：保证高可用，监控各个节点，自动故障迁移
    > + 缺点： 主从模式切换需要时间，丢失数据，没有解决mater写的压力
+ 集群（代理型）：twemproxy是快速单线程的代理服务器。
    > + 优点：支持多种hash算法，支持失败节点自动删除，后端分片逻辑对业务透明，业务读写方式和操作单个redis一致。  
    > + 缺点：新增proxy，需要维护高可用
+ 集群（直连型）：redis3.0之后支持redis-cluster集群，采用无中心化结构，每个节点保存数据和整个集群状态。
    > + 优点：无中心化架构，不存在哪个节点影响性能瓶颈，少了proxy层；节点间数据共享，可动态调整数据分布；可扩展性，线性扩展1000个节点，节点可以动态添加和删除；部分节点不可用，集群任然可用；实现故障自动failover，
    节点之间通过gossip协议交换状态。
    > + 缺点：资源隔离性较差，容易出现相互影响；数据通过异步复制，不保证数据强一致性。。

缓存穿透？
+ 缓存系统通常是按照key去查缓存，如果没有对应的value，就会去后端系统查找，一些恶意的请求会故意查询不存在的key，请求量大，会造成后端系统很大压力，这就是缓存穿透。

如何避免缓存穿透？
+ 1、对查询结果为空也进行缓存，缓存时间设置端点，或者key对应数据插入后清理缓存。
+ 2、对一定不存在的key进行过滤，把所有的可能存在的key放在一个大的bitmap中，查询时通过这个bitmap过滤。

缓存雪崩？
+ 缓存服务器重启，或者大量缓存集中失效，失效的时候，后端系统很大的压力，导致系统奔溃。

redis单线程为啥这么快？
+ redis分为客户端和服务器，一个完整redis请求事件多个阶段：客户端到服务端网络连接-->redis读写事件发生-->redis服务端数据处理(单线程)-->数据返回。
+ redis客户端和服务端是socket通信，redis服务端监听多个客户端请求。
+ 具体回答：redis的核心是数据都在内存里，单线程操作就是效率最高。多线程的本质是CPU模拟多个线程情况，
模拟的线程代价是上下文切换耗时。不用考虑各种锁的问题，不存在加锁释放锁的操作，没有因为死锁导致性能消耗。
所以CPU不是redis的瓶颈，redis的瓶颈最有可能是内存大小和网络带宽。



### 8、谈谈如何渲染优化？
+ 减少DOM操作次数。比如vue和react的虚拟DOM，内存总进行diff算法比较，做到最小化操作真实DOM。
+ 减少重绘重排，比如img标签设置宽高
+ 懒执行：某些逻辑延迟到使用时再计算，比如耗时逻辑可以通过定时器来唤醒。
+ 懒加载：按需加载，将不关键的资源延迟后加载。懒加载可以用于图片，还可以用于视频。
懒加载原理：只加载自定义区域内需要加载东西。



### 9、nginx处理静态文件优势？
nginx相当于大自然搬运工，把网络路径和本地路径做了映射，比如：访问http://www.chengxinsong.cn 其实访问本地的\root\home\songEagle。

通过url路径访问静态资源时，nginx根据映射地址找到资源文件位置，然后就去拿静态资源，返回给客户端。

同时nginx支持压缩，和open_file_cache减少重复打开文件进行优化。加上nginx的高效的事件处理机制。