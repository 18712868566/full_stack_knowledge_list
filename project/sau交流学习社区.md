# [sau交流学习社区](https://www.mwcxs.top/)
sau交流学习社区，一个技术分享和技术谈论的社区，技术栈：thinkjs2+jq+nunjucks+mysql+redis+nginx，个人全栈开发。
拥有文章管理，微型bbs社区，防止csrf攻击，权限管理，定时任务，页面后台配置，github第三方登陆，从中学会了使用
thinkjs后端开发，redis缓存频繁查库的信息，nginx处理静态文件，设计网站安全，优化网站渲染速度。

思考：
### 1、thinkjs2和thinkjs3的区别？
（1）thinkjs1.0在14年发布，360团队的李成银设计和开发，借鉴了thinkphp框架。
thinkjs2.0在15年发布，具备了可扩展性，支持ES6/ES7，支持TypeScript，性能提升。
框架是否出色，一看支持功能，二看性能，thinkjs更适合大型项目，功能和复杂度远超过express和koa，
但是性能不比他们逊色多少。
（2）thinkjs2主要特点：
+ 支持TypeScript
+ 升级babel到6
+ 多级控制器（controller可以建立子目录，目录的深度根据项目复杂度来定）
+ 支持postgreSQL，（目前支持4种数据库，mysql，SQLite，MongoDB，postgreSQL）
（3）thinkjs3.0在17年发布
最大改变时底层架构基于koa2.0重构，koa2.0稳定，koa2.0的洋葱模型的中间件更能满足多维度的需求，thinkjs3兼容koa的中间件，可以说是站在koa这个巨人的肩膀上做的更好。
koa2.0使用更优雅的async/await解决异步问题。node8.0后async/await被原生支持，不用借助babel转译。
+ 2内置很多功能，3不再提供丰富的功能，而是提供最基本核心，通过扩展和适配器可以满足不同需求。
+ 多进程模型，新增think-cluster模块内置多进程模型，最大限度的利用多核CPU提高响应速度，同时提供一套进程之间通信方式，
比如：通知其他进程执行某一个任务，代码更新后会重启所有的子进程。
+ 智能的错误提示。差错和定位问题，尤其是使用babel转译后，所以新增think-trace模块追踪错误问题，显示错误堆栈信息。
+ 强化定时任务功能，新增think-crontab模块。
+ 重构日志功能，基于think-logger3构建日志系统
+ 重构框架操作数据库操作逻辑

### 2、nunjucks模板引擎
nunjucks是Mozilla开发的一个纯js编写的模板引擎，可以运行在node端，又可以运行在浏览器端。nunjucks借鉴用python写的jinja2模板引擎。
我们知道flask框架下的jinja2模板引擎，jinjia2是由python实现的模板语言，设计思想来源于Django模板引擎，是flask框架内置模板语言。

使用模板好处：
+ 视图函数只负责业务逻辑处理和数据处理（业务逻辑方面）
+ 模板取到视图函数的数据结果进行展示（视图展示方面）
+ 代码结构清晰，耦合度低

### 3、项目如何具体防止csrf攻击
csrf是跨站请求伪造，本质是网站对浏览器的信任。简单说，就是利用用户的登陆状态发起恶意请求。

我在系统中做的是所有的接口请求都加csrf，thinkjs有针对csrf的配置，我们举个简单例子：

在页面初始化的时候，后端从session中获取csrf值，然后传到前台页面，前台页面整个影藏域存放csrf值。在base.js中统一assign，这样所有页面都有这个值。
然后发送接口的时候，传输数据添加csrf参数；然后验证这个csrf参数，并且请求时附带验证码或者token。

**进阶**
> 1、还有其他的csrf攻击防御措施吗？
+ 尽量使用post请求，限制使用get请求，get请求不修改数据。post不是万无一失的，攻击者需要伪装一个form，增加了csrf暴露的可能性。
+ 将cookie设置为httpOnly。这样通过程序就无法读取到cookie信息，避免了攻击者伪造cookie情况。
+ 将cookie设置为sameSite属性，不随着跨域请求发送。
+ 请求参数中附带验证信息，比如随机token或者验证码，后端进行校验
+ 通过HTTP头部字段Referer识别，阻止第三方网站访问请求接口。这个字段referer记录http请求的来源地址。

> 2、常见的其他攻击，比如xss？安全策略CSP？密码安全，密码加盐？

xss叫跨网站指令码，通过修改html节点或者执行js攻击网站。如何防御？
+ 转译所有输入和输出的内容，对于括号，尖括号，斜杠进行转译
+ 富文本，可以采用白名单过滤
+ CSP内容安全策略，建立白名单，规定浏览器只能执行特定来源的代码，通过http的header中的content-security-policy来开启csp。


### 4、如何实现github第三方登陆？
第三方登陆实质是OAuth授权。
说一个具体场景：想登陆A网站，A网站让用户提供第三方的数据证明自己的身份。获取第三方网站的身份数据，这就需要Oauth授权。

流程：
+ A网站让用户跳转到Github
+ Github要求用户登陆，然后询问“A网站要求获得XX权限，你是否同意？”
+ 用户同意，Github会重定向回A网站，同时发送一个授权码
+ A网站使用授权码，向Github请求令牌
+ Github返回令牌
+ A网站使用令牌，向Github请求用户数据

### 5、redis缓存
redis是一个开源的，C语言编写，支持网络，可基于内存并且持久化的日志型，key-value数据库，非关系型数据库。**内存中的数据结构存储系统**，可用作数据库，缓存和消息中间件。

支持多种数据类型：
+ 字符串（String）
+ 字典（hash）
+ 列表（list）
+ 集合（set）
+ 有序集合（sorted set）

基本配合后端数据库使用，存放只是用户当前频繁调用的数据。

功能特点：
+ 高速读写（因为内存上的数据库）
+ 数据类型丰富
+ 支持持久化AOF和RDB
+ 多种内存分配及回收策略
+ 支持多事物
+ 消息队列，消息订阅
+ 支持高可用
+ 支持分布式分片集群

优点：高性能读写，多数据类型支持，数据持久化，高可用架构，支持自定义虚拟内存，支持分布式分片集群，单线程读写性能高。

缺点：多线程读写较mencached慢。

什么是redis持久化？有几种持久化方式，优缺点？
+ 持久化：把redis内存中的数据写到磁盘中，防止服务器宕机了内存数据丢失。
+ 方式：RDB（默认）和AOF
+ 优缺点：RDB是数据快照，指定间隔对数据快照。AOF是执行写操作的时候会触发，写入保护。
+ 存储结构：内饰RESP协议的文本存储
+ 比较：1、AOF比RDB更新频率高，优先使用AOF还原数据。2、AOF比RDB安全，更大。3、RDB性能比AOF好。4、两个都配置时，优先加载AOF。

什么是RESP通讯协议？
+ redis客户端和服务端之间使用的通讯协议
+ 特点：实现简单，快速解析，可读性好

redis的架构模式及特点？
+ 单机版
    > + 优点：简单，
    > + 缺点：但是内存容量有限，处理能力有限，无法高可用。
+ 主从复制：主从服务器之间更新同步
    > + 优点：主从服务器会具有相同的数据，降低住服务器压力转交给从库。
    > + 缺点：无法高可用，没有解决master写的压力
+ 哨兵：使用sentinel监控主从服务器
    > + 优点：保证高可用，监控各个节点，自动故障迁移
    > + 缺点： 主从模式切换需要时间，丢失数据，没有解决mater写的压力
+ 集群（代理型）：twemproxy是快速单线程的代理服务器。
    > + 优点：支持多种hash算法，支持失败节点自动删除，后端分片逻辑对业务透明，业务读写方式和操作单个redis一致。  
    > + 缺点：新增proxy，需要维护高可用
+ 集群（直连型）：redis3.0之后支持redis-cluster集群，采用无中心化结构，每个节点保存数据和整个集群状态。
    > + 优点：无中心化架构，不存在哪个节点影响性能瓶颈，少了proxy层；节点间数据共享，可动态调整数据分布；可扩展性，线性扩展1000个节点，节点可以动态添加和删除；部分节点不可用，集群任然可用；实现故障自动failover，
    节点之间通过gossip协议交换状态。
    > + 缺点：资源隔离性较差，容易出现相互影响；数据通过异步复制，不保证数据强一致性。。

缓存穿透？
+ 缓存系统通常是按照key去查缓存，如果没有对应的value，就会去后端系统查找，一些恶意的请求会故意查询不存在的key，请求量大，会造成后端系统很大压力，这就是缓存穿透。

如何避免缓存穿透？
+ 1、对查询结果为空也进行缓存，缓存时间设置端点，或者key对应数据插入后清理缓存。
+ 2、对一定不存在的key进行过滤，把所有的可能存在的key放在一个大的bitmap中，查询时通过这个bitmap过滤。

缓存雪崩？
+ 缓存服务器重启，或者大量缓存集中失效，失效的时候，后端系统很大的压力，导致系统奔溃。

redis单线程为啥这么快？
+ redis分为客户端和服务器，一个完整redis请求事件多个阶段：客户端到服务端网络连接-->redis读写事件发生-->redis服务端数据处理(单线程)-->数据返回。
+ redis客户端和服务端是socket通信，redis服务端监听多个客户端请求。
+ 具体回答：redis的核心是数据都在内存里，单线程操作就是效率最高。多线程的本质是CPU模拟多个线程情况，
模拟的线程代价是上下文切换耗时。不用考虑各种锁的问题，不存在加锁释放锁的操作，没有因为死锁导致性能消耗。
所以CPU不是redis的瓶颈，redis的瓶颈最有可能是内存大小和网络带宽。



### 6、谈谈如何渲染优化？
+ 减少DOM操作次数。比如vue和react的虚拟DOM，内存总进行diff算法比较，做到最小化操作真实DOM。
+ 减少重绘重排，比如img标签设置宽高
+ 懒执行：某些逻辑延迟到使用时再计算，比如耗时逻辑可以通过定时器或者事件来唤醒。
+ 懒加载：按需加载，将不关键的资源延迟后加载。懒加载可以用于图片，还可以用于视频。
懒加载原理：只加载自定义区域内需要加载东西。

**进阶**：
开发中性能优化的方案：
+ 1、网络性能优化：
    > + (1)DNS预解析，预先获取域名对应的IP
    > + (2)缓存：强缓存和协商缓存。
    > + (3)强缓存：表示缓存期间不需要请求，通过响应头设置Expires和cache-control。
    > + (4)协商缓存：如果缓存过期，我们需要使用协商缓存来解决问题，协商缓存需要请求，缓存有效返回304；协商缓存客户端和服务端共同实现；Etag和IF-None-Match，Etag类似
    指纹，有变动就将新资源返回。
    > + (5)合适的缓存策略：大部分场景就可以使用强缓存配合协商缓存解决，还有特殊的缓存策略。比如不需要缓存的资源，使用cache-control：no-store。
    对于频繁变动的资源，cache-control：np-cache配合Etag使用，表示资源被缓存，但是每次都会发请求询问资源是都更新。
    > + (6)使用htttp2.0：http1.1，每一个请求都需要建立和断开，消耗好几个RTT时间，并且由于TCP慢启动的原因，加载体积大的文件需要消耗更多时间。
    http2.0引入多路复用，能够让多个请求使用同一个TCP链接，极大的加快了网页的加载速度，支持header压缩，减少请求数据大小。
    > + (7)预加载：比如有的资源不需要马上用，但是需要尽早获取，预加载其实是声明式的fetch，强制浏览器请求资源，并且不会阻塞onload事件。在link标签中使用rel属性preload。
    > + (8)预渲染：将下载的文件预先在后台渲染，提高页面的加载速度。    
+ 2、渲染优化：
    > + (1)减少DOM操作次数。比如vue和react的虚拟DOM，内存总进行diff算法比较，做到最小化操作真实DOM。
    > + (2)减少重绘重排，比如img标签设置宽高
    > + (3)懒执行：将某些逻辑延迟到使用时再计算。首屏优化，把耗时的逻辑不在首屏中使用，使用懒执行，一般通过定时器或者事件调用唤醒。
    > + (4)懒加载：将不关键的资源延后加载。原理就是只加载自定义区域内需要加载的东西，比如常见图片懒加载和视频懒加载
+ 3、文件优化：
    > + (1)图片大小优化：减少像素点和减少像素点能够显示的颜色
    > + (2)图片加载优化：1、不用修饰类图片，使用css去代替。2、移动端图片，不用原图，用cdn加载，计算适配宽度，请求相应裁剪好的图片。3、小图使用base64格式。4、多个图标文件合并到一张图中。
    5、使用正确的图片格式，优先使用webp，小图使用png或者svg代替，照片使用jpg。
    > + (3)其他文件优化：1、css放在head中。2、服务端开启文件压缩功能。3、script放在body底部，js执行会阻止渲染，价格defer会并行下载，但是不会执行，等到html解析完成后顺序执行，没有任何依赖的可以加async，表示渲染和js下载和执行并行进行。
    4、js代码过长会卡住渲染，可以考虑使用webworker,新开线程执行脚本不会影响渲染。    
    > + (4)CDN：静态资源尽量使用CDN加载
+ 4、使用webpack优化项目：
    + webpack4，打包项目使用production模式，会自动开启代码压缩
    + 使用ES6的模块开启tree shaking，移除没有使用的代码
    + 优化图片，小图使用base64写入文件中
    + 按照路由拆分代码，实现按需加载
    + 给打包出来的文件名添加哈希，实现浏览器缓存文件


### 7、nginx处理静态文件优势？
nginx相当于大自然搬运工，把网络路径和本地路径做了映射，比如：访问http://www.chengxinsong.cn 其实访问本地的\root\home\songEagle。

通过url路径访问静态资源时，nginx根据映射地址找到资源文件位置，然后就去拿静态资源，返回给客户端。

+ 1、网络和本地路径做映射
+ 2、nginx支持压缩，
+ 3、open_file_cache减少重复打开文件进行优化，
+ 4、nginx的高效的事件处理机制。
